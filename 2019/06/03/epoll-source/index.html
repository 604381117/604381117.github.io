<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","width":240,"display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="APIepoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系和含义。  int epoll_create1(int size)；  创建一个epfd句柄，size为0时等价于int epoll_create(0)。  int epoll_ctl(int epfd, int op, int fd, st">
<meta name="keywords" content="epoll">
<meta property="og:type" content="article">
<meta property="og:title" content="epoll源码分析(基于linux-5.1.4)">
<meta property="og:url" content="https://icoty.github.io/2019/06/03/epoll-source/index.html">
<meta property="og:site_name" content="荒野之萍">
<meta property="og:description" content="APIepoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系和含义。  int epoll_create1(int size)；  创建一个epfd句柄，size为0时等价于int epoll_create(0)。  int epoll_ctl(int epfd, int op, int fd, st">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://icoty.github.io/2019/06/03/epoll-source/epoll-data-structure.png">
<meta property="og:image" content="https://icoty.github.io/2019/06/03/epoll-source/epoll-sequence">
<meta property="og:updated_time" content="2019-06-05T14:02:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="epoll源码分析(基于linux-5.1.4)">
<meta name="twitter:description" content="APIepoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系和含义。  int epoll_create1(int size)；  创建一个epfd句柄，size为0时等价于int epoll_create(0)。  int epoll_ctl(int epfd, int op, int fd, st">
<meta name="twitter:image" content="https://icoty.github.io/2019/06/03/epoll-source/epoll-data-structure.png">



  <link rel="alternate" href="/atom.xml" title="荒野之萍" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://icoty.github.io/2019/06/03/epoll-source/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>epoll源码分析(基于linux-5.1.4) | 荒野之萍</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">荒野之萍</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">忙着活或忙着死</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/icoty" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://icoty.github.io/2019/06/03/epoll-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icoty">
      <meta itemprop="description" content="后台 / 系统">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="荒野之萍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">epoll源码分析(基于linux-5.1.4)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-03 12:49:38" itemprop="dateCreated datePublished" datetime="2019-06-03T12:49:38+00:00">2019-06-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-05 14:02:51" itemprop="dateModified" datetime="2019-06-05T14:02:51+00:00">2019-06-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux内核源码/" itemprop="url" rel="index"><span itemprop="name">linux内核源码</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/03/epoll-source/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/03/epoll-source/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>epoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系和含义。</p>
<ol>
<li><p>int epoll_create1(int size)；</p>
<p> 创建一个epfd句柄，size为0时等价于int epoll_create(0)。</p>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</p>
<pre><code>向epfd上添加/修改/删除fd。
</code></pre></li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)；</p>
<p>返回所有就绪的fd。</p>
</li>
</ol>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>先上一张UML类图，从整体进行把握，图中已经标出各个数据结构所在的文件。</p>
<p><img src="/2019/06/03/epoll-source/epoll-data-structure.png" alt="cmd"></p>
<p>下面贴出各个数据结构代码，切记，实际在过代码的时候，其实我们没有必要对每一个变量和每一行代码咬文嚼字，也不建议这样去做，我们只需要重点关注主要的数据成员和那些关键的代码行，把心思和精力投入到我们最该关注的那部分，从框架层面去把握整体，抓准各个模块的核心，各个模块之间如何耦合，如何同步，如何通信等，这才是能够让你快速进步的最优路线。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Each file descriptor added to the eventpoll interface will</span><br><span class="line">* have an entry of this <span class="built_in">type</span> linked to the <span class="string">"rbr"</span> RB tree.</span><br><span class="line">* Avoid increasing the size of this struct, there can be many thousands</span><br><span class="line">* of these on a server and we <span class="keyword">do</span> not want this to take another cache line.</span><br><span class="line">*/</span><br><span class="line">struct epitem &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        /* RB tree node links this structure to the eventpoll RB tree */</span><br><span class="line">        struct rb_node rbn;</span><br><span class="line">        /* Used to free the struct epitem */</span><br><span class="line">        struct rcu_head rcu;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /* List header used to link this structure to the eventpoll ready list */</span><br><span class="line">    struct list_head rdllink;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Works together <span class="string">"struct eventpoll"</span>-&gt;ovflist <span class="keyword">in</span> keeping the</span><br><span class="line">    * single linked chain of items.</span><br><span class="line">    */</span><br><span class="line">    struct epitem *next;</span><br><span class="line"></span><br><span class="line">    /* The file descriptor information this item refers to */</span><br><span class="line">    struct epoll_filefd ffd;</span><br><span class="line"></span><br><span class="line">    /* Number of active <span class="built_in">wait</span> queue attached to poll operations */</span><br><span class="line">    int nwait;</span><br><span class="line"></span><br><span class="line">    /* List containing poll <span class="built_in">wait</span> queues */</span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line"></span><br><span class="line">    /* The <span class="string">"container"</span> of this item */</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    /* List header used to link this item to the <span class="string">"struct file"</span> items list */</span><br><span class="line">    struct list_head fllink;</span><br><span class="line"></span><br><span class="line">    /* wakeup_source used when EPOLLWAKEUP is <span class="built_in">set</span> */</span><br><span class="line">    struct wakeup_source __rcu *ws;</span><br><span class="line"></span><br><span class="line">    /* The structure that describe the interested events and the <span class="built_in">source</span> fd */</span><br><span class="line">    struct epoll_event event;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* This structure is stored inside the <span class="string">"private_data"</span> member of the file</span><br><span class="line">* structure and represents the main data structure <span class="keyword">for</span> the eventpoll</span><br><span class="line">* interface.</span><br><span class="line">*/</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line">    /*</span><br><span class="line">    * This mutex is used to ensure that files are not removed</span><br><span class="line">    * <span class="keyword">while</span> epoll is using them. This is held during the event</span><br><span class="line">    * collection loop, the file cleanup path, the epoll file <span class="built_in">exit</span></span><br><span class="line">    * code and the ctl operations.</span><br><span class="line">    */</span><br><span class="line">    struct mutex mtx;</span><br><span class="line"></span><br><span class="line">    /* Wait queue used by sys_epoll_wait() */</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line"></span><br><span class="line">    /* Wait queue used by file-&gt;poll() */</span><br><span class="line">    wait_queue_head_t poll_wait;</span><br><span class="line"></span><br><span class="line">    /* List of ready file descriptors */</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line"></span><br><span class="line">    /* Lock <span class="built_in">which</span> protects rdllist and ovflist */</span><br><span class="line">    rwlock_t lock;</span><br><span class="line"></span><br><span class="line">    /* RB tree root used to store monitored fd structs */</span><br><span class="line">    struct rb_root_cached rbr;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * This is a single linked list that chains all the <span class="string">"struct epitem"</span> that</span><br><span class="line">    * happened <span class="keyword">while</span> transferring ready events to userspace w/out</span><br><span class="line">    * holding -&gt;lock.</span><br><span class="line">    */</span><br><span class="line">    struct epitem *ovflist;</span><br><span class="line"></span><br><span class="line">    /* wakeup_source used when ep_scan_ready_list is running */</span><br><span class="line">    struct wakeup_source *ws;</span><br><span class="line"></span><br><span class="line">    /* The user that created the eventpoll descriptor */</span><br><span class="line">    struct user_struct *user;</span><br><span class="line"></span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    /* used to optimize loop detection check */</span><br><span class="line">    int visited;</span><br><span class="line">    struct list_head visited_list_link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#ifdef CONFIG_NET_RX_BUSY_POLL</span></span><br><span class="line">    /* used to track busy poll napi_id */</span><br><span class="line">    unsigned int napi_id;</span><br><span class="line">    <span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Wait structure used by the poll hooks */</span><br><span class="line">struct eppoll_entry &#123;</span><br><span class="line">    /* List header used to link this structure to the <span class="string">"struct epitem"</span> */</span><br><span class="line">    struct list_head llink;</span><br><span class="line"></span><br><span class="line">    /* The <span class="string">"base"</span> pointer is <span class="built_in">set</span> to the container <span class="string">"struct epitem"</span> */</span><br><span class="line">    struct epitem *base;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Wait queue item that will be linked to the target file <span class="built_in">wait</span></span><br><span class="line">     * queue head.</span><br><span class="line">     */</span><br><span class="line">    wait_queue_entry_t <span class="built_in">wait</span>;</span><br><span class="line"></span><br><span class="line">    /* The <span class="built_in">wait</span> queue head that linked the <span class="string">"wait"</span> <span class="built_in">wait</span> queue item */</span><br><span class="line">    wait_queue_head_t *whead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Wrapper struct used by poll queueing */</span><br><span class="line">struct ep_pqueue &#123;</span><br><span class="line">    poll_table pt;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="全局调用关系"><a href="#全局调用关系" class="headerlink" title="全局调用关系"></a>全局调用关系</h2><p>再贴一张各个API从用户进程陷入到内核态并执行系统调用的详细过程，以及client发数据过来时触发ep_poll_callback回调函数的执行流程。</p>
<p><img src="/2019/06/03/epoll-source/epoll-sequence" alt="cmd"></p>
<h2 id="epoll模块初始化-amp-内存池开辟"><a href="#epoll模块初始化-amp-内存池开辟" class="headerlink" title="epoll模块初始化&amp;内存池开辟"></a>epoll模块初始化&amp;内存池开辟</h2><p>epoll是内核的一个module，内核启动时会初始化这个module。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">static int __init eventpoll_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sysinfo si;</span><br><span class="line"></span><br><span class="line">    si_meminfo(&amp;si);</span><br><span class="line">    /*</span><br><span class="line">     * Allows top 4% of lomem to be allocated <span class="keyword">for</span> epoll watches (per user).</span><br><span class="line">     */</span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) /</span><br><span class="line">        EP_ITEM_COST;</span><br><span class="line">    BUG_ON(max_user_watches &lt; 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Initialize the structure used to perform epoll file descriptor</span><br><span class="line">     * inclusion loops checks.</span><br><span class="line">     */</span><br><span class="line">    ep_nested_calls_init(&amp;poll_loop_ncalls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    /* Initialize the structure used to perform safe poll <span class="built_in">wait</span> head wake ups */</span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);</span><br><span class="line">    <span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We can have many thousands of epitems, so prevent this from</span><br><span class="line">     * using an extra cache line on 64-bit (and smaller) CPUs</span><br><span class="line">     */</span><br><span class="line">    BUILD_BUG_ON(sizeof(void *) &lt;= 8 &amp;&amp; sizeof(struct epitem) &gt; 128);</span><br><span class="line"></span><br><span class="line">    // 提前开辟eventpoll_epi内存池,UML时序图的第21步alloc时直接从内存池里取,</span><br><span class="line">    // 而不是重新调用malloc,效率得以提高</span><br><span class="line">    /* Allocates slab cache used to allocate <span class="string">"struct epitem"</span> items */</span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, sizeof(struct epitem),0, placehold_flag, 0);</span><br><span class="line"></span><br><span class="line">    // 提前开辟eventpoll_pwq内存池,UML时序图的第28步alloc时直接从内存池里取</span><br><span class="line">    // 而不是重新调用malloc,效率得以提高</span><br><span class="line">    /* Allocates slab cache used to allocate <span class="string">"struct eppoll_entry"</span> */</span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">"eventpoll_pwq"</span>,</span><br><span class="line">        sizeof(struct eppoll_entry), 0, SLAB_PANIC|SLAB_ACCOUNT, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(eventpoll_init);</span><br></pre></td></tr></table></figure>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>用户空间调用epoll_create(0)或epoll_create1(int)，其实质就是在名为”eventpollfs”的文件系统里创建了一个新文件，同时为该文件申请一个fd，绑定一个inode，最后返回该文件句柄。</p>
<ol>
<li>用户进程执行epoll_create或epoll_create1时，陷入内核态，执行如下对应接口：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_create(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(epoll_create, int, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_create(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>do_epoll_create(flags)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Open an eventpoll file descriptor.</span><br><span class="line"> */</span><br><span class="line">static int do_epoll_create(int flags)</span><br><span class="line">&#123;</span><br><span class="line">    int error, fd;</span><br><span class="line">    struct eventpoll *ep = NULL;</span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    /* Check the EPOLL_* constant <span class="keyword">for</span> consistency.  */</span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    /*</span><br><span class="line">     * 申请一个struct eventpoll内存空间,执行初始化后赋给ep</span><br><span class="line">     * Create the internal data structure (<span class="string">"struct eventpoll"</span>).</span><br><span class="line">     */</span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> error;</span><br><span class="line">    /*</span><br><span class="line">     * 获取一个未使用的fd句柄</span><br><span class="line">     * Creates all the items needed to setup an eventpoll file. That is,</span><br><span class="line">     * a file structure and a free file descriptor.</span><br><span class="line">     */</span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; 0) &#123;</span><br><span class="line">        error = fd;</span><br><span class="line">        goto out_free_ep;</span><br><span class="line">    &#125;</span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                              O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        goto out_free_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">    // 绑定fd和file</span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    // 这个fd就是epfd句柄,返回给用户进程的</span><br><span class="line">    <span class="built_in">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// fs/eventpoll.c</span><br><span class="line">// 形参是一个二级指针,该接口就是简单的分配一个struct eventpoll,然后执行初始化工作</span><br><span class="line">static int ep_alloc(struct eventpoll **pep)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct user_struct *user;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    user = get_current_user();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = kzalloc(sizeof(*ep), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!ep))</span><br><span class="line">        goto free_uid;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;ep-&gt;mtx);</span><br><span class="line">    rwlock_init(&amp;ep-&gt;lock);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;wq);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;poll_wait);</span><br><span class="line">    INIT_LIST_HEAD(&amp;ep-&gt;rdllist);</span><br><span class="line">    ep-&gt;rbr = RB_ROOT_CACHED;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line"></span><br><span class="line">    *pep = ep;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">free_uid:</span><br><span class="line">    free_uid(user);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>anon_inode_getfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * fs/anon_inodes.c</span><br><span class="line"> * anon_inode_getfile - creates a new file instance by hooking it up to an</span><br><span class="line"> *                      anonymous inode, and a dentry that describe the <span class="string">"class"</span></span><br><span class="line"> *                      of the file</span><br><span class="line"> *</span><br><span class="line"> * @name:    [<span class="keyword">in</span>]    name of the <span class="string">"class"</span> of the new file</span><br><span class="line"> * @fops:    [<span class="keyword">in</span>]    file operations <span class="keyword">for</span> the new file</span><br><span class="line"> * @priv:    [<span class="keyword">in</span>]    private data <span class="keyword">for</span> the new file (will be file<span class="string">'s private_data)</span></span><br><span class="line"><span class="string"> * @flags:   [in]    flags</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Creates a new file by hooking it on a single inode. This is useful for files</span></span><br><span class="line"><span class="string"> * that do not need to have a full-fledged inode in order to operate correctly.</span></span><br><span class="line"><span class="string"> * All the files created with anon_inode_getfile() will share a single inode,</span></span><br><span class="line"><span class="string"> * hence saving memory and avoiding code duplication for the file/inode/dentry</span></span><br><span class="line"><span class="string"> * setup.  Returns the newly created file* or an error pointer.</span></span><br><span class="line"><span class="string"> * 在一个inode上挂接一个新文件,这对于不需要完整inode才能正确操作的文件非常有用。</span></span><br><span class="line"><span class="string"> * 使用anon_inode_getfile()创建的所有文件都将共享一个inode，</span></span><br><span class="line"><span class="string"> * 因此可以节省内存并避免文件/inode/dentry设置的代码重复。</span></span><br><span class="line"><span class="string"> * 返回新创建的文件*或错误指针。</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">struct file *anon_inode_getfile(const char *name,const struct file_operations *fops,void *priv, int flags)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (IS_ERR(anon_inode_inode))</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENODEV);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (fops-&gt;owner &amp;&amp; !try_module_get(fops-&gt;owner))</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENOENT);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * We know the anon_inode inode count is always greater than zero,</span></span><br><span class="line"><span class="string">    * so ihold() is safe.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    ihold(anon_inode_inode);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // 创建一个名字为“[eventpoll]”的eventpollfs文件描述符</span></span><br><span class="line"><span class="string">    file = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,</span></span><br><span class="line"><span class="string">                             flags &amp; (O_ACCMODE | O_NONBLOCK), fops);</span></span><br><span class="line"><span class="string">    if (IS_ERR(file))</span></span><br><span class="line"><span class="string">        goto err;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file-&gt;f_mapping = anon_inode_inode-&gt;i_mapping;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // file-&gt;private_data指向传进来的priv( = struct eventpoll *ep)</span></span><br><span class="line"><span class="string">    file-&gt;private_data = priv;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err:</span></span><br><span class="line"><span class="string">    iput(anon_inode_inode);</span></span><br><span class="line"><span class="string">    module_put(fops-&gt;owner);</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL_GPL(anon_inode_getfile);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	// fs/file_table.c</span></span><br><span class="line"><span class="string">struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,const char *name, int flags,const struct file_operations *fops)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    static const struct dentry_operations anon_ops = &#123;</span></span><br><span class="line"><span class="string">        .d_dname = simple_dname</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    struct qstr this = QSTR_INIT(name, strlen(name));</span></span><br><span class="line"><span class="string">    struct path path;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 挂载名为“[eventpoll]”的eventpollfs文件系统</span></span><br><span class="line"><span class="string">    path.dentry = d_alloc_pseudo(mnt-&gt;mnt_sb, &amp;this);</span></span><br><span class="line"><span class="string">    if (!path.dentry)</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENOMEM);</span></span><br><span class="line"><span class="string">    if (!mnt-&gt;mnt_sb-&gt;s_d_op)</span></span><br><span class="line"><span class="string">        d_set_d_op(path.dentry, &amp;anon_ops);</span></span><br><span class="line"><span class="string">    path.mnt = mntget(mnt);</span></span><br><span class="line"><span class="string">    d_instantiate(path.dentry, inode);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // inode和file绑定，返回绑定后的file结构</span></span><br><span class="line"><span class="string">    file = alloc_file(&amp;path, flags, fops);</span></span><br><span class="line"><span class="string">    if (IS_ERR(file)) &#123;</span></span><br><span class="line"><span class="string">        ihold(inode);</span></span><br><span class="line"><span class="string">        path_put(&amp;path);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL(alloc_file_pseudo);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * fs/file_table.c</span></span><br><span class="line"><span class="string"> * alloc_file - allocate and initialize a '</span>struct file<span class="string">'</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @path: the (dentry, vfsmount) pair for the new file</span></span><br><span class="line"><span class="string"> * @flags: O_... flags with which the new file will be opened</span></span><br><span class="line"><span class="string"> * @fop: the '</span>struct file_operations<span class="string">' for the new file</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static struct file *alloc_file(const struct path *path, int flags,const struct file_operations *fop)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	    // 申请一个空的file结构</span></span><br><span class="line"><span class="string">    file = alloc_empty_file(flags, current_cred());</span></span><br><span class="line"><span class="string">    if (IS_ERR(file))</span></span><br><span class="line"><span class="string">        return file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file-&gt;f_path = *path;</span></span><br><span class="line"><span class="string">    file-&gt;f_inode = path-&gt;dentry-&gt;d_inode;</span></span><br><span class="line"><span class="string">    file-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;</span></span><br><span class="line"><span class="string">    file-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(fop-&gt;read || fop-&gt;read_iter))</span></span><br><span class="line"><span class="string">        file-&gt;f_mode |= FMODE_CAN_READ;</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(fop-&gt;write || fop-&gt;write_iter))</span></span><br><span class="line"><span class="string">        file-&gt;f_mode |= FMODE_CAN_WRITE;</span></span><br><span class="line"><span class="string">    file-&gt;f_mode |= FMODE_OPENED;</span></span><br><span class="line"><span class="string">    file-&gt;f_op = fop;</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)</span></span><br><span class="line"><span class="string">        i_readcount_inc(path-&gt;dentry-&gt;d_inode);</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br></pre></td><td class="code"><pre><span class="line">// 用户空间调用int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)，向</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * The following <span class="keyword">function</span> implements the controller interface <span class="keyword">for</span></span><br><span class="line"> * the eventpoll file that enables the insertion/removal/change of</span><br><span class="line"> * file descriptors inside the interest <span class="built_in">set</span>.</span><br><span class="line"> */</span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,</span><br><span class="line">		struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line">	int full_check = 0;</span><br><span class="line">	</span><br><span class="line">	/* struct fd &#123;</span><br><span class="line">	 * struct file *file;</span><br><span class="line">	 * unsigned int flags;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">	struct fd f, tf;</span><br><span class="line">	struct eventpoll *ep;</span><br><span class="line">	struct epitem *epi;</span><br><span class="line">	struct epoll_event epds;</span><br><span class="line">	struct eventpoll *tep = NULL;</span><br><span class="line"></span><br><span class="line">	error = -EFAULT;</span><br><span class="line">	// copy_from_user将用户空间关注的event事件拷贝到内核空间</span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">	    copy_from_user将用户空间关注的(&amp;epds, event, sizeof(struct epoll_event)))</span><br><span class="line">		goto error_return;</span><br><span class="line"></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	f = fdget(epfd);</span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		goto error_return;</span><br><span class="line"></span><br><span class="line">	/* Get the <span class="string">"struct file *"</span> <span class="keyword">for</span> the target file */</span><br><span class="line">	tf = fdget(fd);</span><br><span class="line">	<span class="keyword">if</span> (!tf.file)</span><br><span class="line">		goto error_fput;</span><br><span class="line"></span><br><span class="line">	/* The target file descriptor must support poll */</span><br><span class="line">	error = -EPERM;</span><br><span class="line">	<span class="keyword">if</span> (!file_can_poll(tf.file))</span><br><span class="line">		goto error_tgt_fput;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">/* 如果系统设置了自动休眠模式（通过/sys/power/autosleep），</span><br><span class="line"> * 当唤醒设备的事件发生时，设备驱动会保持唤醒状态，直到事件进入排队状态。</span><br><span class="line"> * 为了保持设备唤醒直到事件处理完成，必须使用epoll EPOLLWAKEUP 标记。</span><br><span class="line"> * 一旦给structe poll_event中的events字段设置了EPOLLWAKEUP标记，系统会在事件排队时就保持唤醒，</span><br><span class="line"> * 从epoll_wait调用开始，持续要下一次epoll_wait调用。</span><br><span class="line"> */</span><br><span class="line">	/* Check <span class="keyword">if</span> EPOLLWAKEUP is allowed */</span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">		ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We have to check that the file structure underneath the file descriptor</span><br><span class="line">	 * the user passed to us _is_ an eventpoll file. And also we <span class="keyword">do</span> not permit</span><br><span class="line">	 * adding an epoll file descriptor inside itself.</span><br><span class="line">	 */</span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))</span><br><span class="line">		goto error_tgt_fput;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,</span><br><span class="line">	 * so EPOLLEXCLUSIVE is not allowed <span class="keyword">for</span> a EPOLL_CTL_MOD operation.</span><br><span class="line">	 * Also, we <span class="keyword">do</span> not currently supported nested exclusive wakeups.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (op == EPOLL_CTL_MOD)</span><br><span class="line">			goto error_tgt_fput;</span><br><span class="line">		<span class="keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||</span><br><span class="line">				(epds.events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))</span><br><span class="line">			goto error_tgt_fput;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * At this point it is safe to assume that the <span class="string">"private_data"</span> contains</span><br><span class="line">	 * our own data structure.</span><br><span class="line">	 */</span><br><span class="line">	ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * When we insert an epoll file descriptor, inside another epoll file</span><br><span class="line">	 * descriptor, there is the change of creating closed loops, <span class="built_in">which</span> are</span><br><span class="line">	 * better be handled here, than <span class="keyword">in</span> more critical paths. While we are</span><br><span class="line">	 * checking <span class="keyword">for</span> loops we also determine the list of files reachable</span><br><span class="line">	 * and hang them on the tfile_check_list, so we can check that we</span><br><span class="line">	 * haven<span class="string">'t created too many possible wakeup paths.</span></span><br><span class="line"><span class="string">	 *</span></span><br><span class="line"><span class="string">	 * We do not need to take the global '</span>epumutex<span class="string">' on EPOLL_CTL_ADD when</span></span><br><span class="line"><span class="string">	 * the epoll file descriptor is attaching directly to a wakeup source,</span></span><br><span class="line"><span class="string">	 * unless the epoll file descriptor is nested. The purpose of taking the</span></span><br><span class="line"><span class="string">	 * '</span>epmutex<span class="string">' on add is to prevent complex toplogies such as loops and</span></span><br><span class="line"><span class="string">	 * deep wakeup paths from forming in parallel through multiple</span></span><br><span class="line"><span class="string">	 * EPOLL_CTL_ADD operations.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	mutex_lock_nested(&amp;ep-&gt;mtx, 0);</span></span><br><span class="line"><span class="string">	if (op == EPOLL_CTL_ADD) &#123;</span></span><br><span class="line"><span class="string">		if (!list_empty(&amp;f.file-&gt;f_ep_links) ||</span></span><br><span class="line"><span class="string">						is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">			full_check = 1;</span></span><br><span class="line"><span class="string">			mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string">			mutex_lock(&amp;epmutex);</span></span><br><span class="line"><span class="string">			if (is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">				error = -ELOOP;</span></span><br><span class="line"><span class="string">				if (ep_loop_check(ep, tf.file) != 0) &#123;</span></span><br><span class="line"><span class="string">					clear_tfile_check_list();</span></span><br><span class="line"><span class="string">					goto error_tgt_fput;</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125; else</span></span><br><span class="line"><span class="string">				list_add(&amp;tf.file-&gt;f_tfile_llink,</span></span><br><span class="line"><span class="string">							&amp;tfile_check_list);</span></span><br><span class="line"><span class="string">			mutex_lock_nested(&amp;ep-&gt;mtx, 0);</span></span><br><span class="line"><span class="string">			if (is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">				tep = tf.file-&gt;private_data;</span></span><br><span class="line"><span class="string">				mutex_lock_nested(&amp;tep-&gt;mtx, 1);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Try to lookup the file inside our RB tree, Since we grabbed "mtx"</span></span><br><span class="line"><span class="string">	 * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="string">	 * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="string">	 * 从红黑树中寻找添加的fd是否存在，存在则返回，否则返回NULL</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	epi = ep_find(ep, tf.file, fd);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	error = -EINVAL;</span></span><br><span class="line"><span class="string">	switch (op) &#123;</span></span><br><span class="line"><span class="string">	case EPOLL_CTL_ADD:</span></span><br><span class="line"><span class="string">		if (!epi) &#123;</span></span><br><span class="line"><span class="string">			epds.events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line"><span class="string">			// 如果不存在则添加，已经存在不重复添加</span></span><br><span class="line"><span class="string">			error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span></span><br><span class="line"><span class="string">		&#125; else</span></span><br><span class="line"><span class="string">			error = -EEXIST;</span></span><br><span class="line"><span class="string">		if (full_check)</span></span><br><span class="line"><span class="string">			clear_tfile_check_list();</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	case EPOLL_CTL_DEL:</span></span><br><span class="line"><span class="string">		if (epi)</span></span><br><span class="line"><span class="string">			error = ep_remove(ep, epi);</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			error = -ENOENT;</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	case EPOLL_CTL_MOD:</span></span><br><span class="line"><span class="string">		if (epi) &#123;</span></span><br><span class="line"><span class="string">			if (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;</span></span><br><span class="line"><span class="string">				epds.events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line"><span class="string">				error = ep_modify(ep, epi, &amp;epds);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125; else</span></span><br><span class="line"><span class="string">			error = -ENOENT;</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	if (tep != NULL)</span></span><br><span class="line"><span class="string">		mutex_unlock(&amp;tep-&gt;mtx);</span></span><br><span class="line"><span class="string">	mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_tgt_fput:</span></span><br><span class="line"><span class="string">	if (full_check)</span></span><br><span class="line"><span class="string">		mutex_unlock(&amp;epmutex);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	fdput(tf);</span></span><br><span class="line"><span class="string">error_fput:</span></span><br><span class="line"><span class="string">	fdput(f);</span></span><br><span class="line"><span class="string">error_return:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * Search the file inside the eventpoll tree. The RB tree operations</span></span><br><span class="line"><span class="string"> * are protected by the "mtx" mutex, and ep_find() must be called with</span></span><br><span class="line"><span class="string"> * "mtx" held.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int kcmp;</span></span><br><span class="line"><span class="string">	struct rb_node *rbp;</span></span><br><span class="line"><span class="string">	struct epitem *epi, *epir = NULL;</span></span><br><span class="line"><span class="string">	struct epoll_filefd ffd;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	ep_set_ffd(&amp;ffd, file, fd);</span></span><br><span class="line"><span class="string">	for (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span></span><br><span class="line"><span class="string">		epi = rb_entry(rbp, struct epitem, rbn);</span></span><br><span class="line"><span class="string">		kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span></span><br><span class="line"><span class="string">		if (kcmp &gt; 0)</span></span><br><span class="line"><span class="string">			rbp = rbp-&gt;rb_right;</span></span><br><span class="line"><span class="string">		else if (kcmp &lt; 0)</span></span><br><span class="line"><span class="string">			rbp = rbp-&gt;rb_left;</span></span><br><span class="line"><span class="string">		else &#123;</span></span><br><span class="line"><span class="string">			epir = epi;</span></span><br><span class="line"><span class="string">			break;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return epir;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * Must be called with "mtx" held.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int ep_insert(struct eventpoll *ep, const struct epoll_event *event,struct file *tfile, int fd, int full_check)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int error, pwake = 0;</span></span><br><span class="line"><span class="string">	__poll_t revents;</span></span><br><span class="line"><span class="string">	long user_watches;</span></span><br><span class="line"><span class="string">	struct epitem *epi;</span></span><br><span class="line"><span class="string">/* </span></span><br><span class="line"><span class="string">	 * Wrapper struct used by poll queueing </span></span><br><span class="line"><span class="string"> * struct ep_pqueue &#123;</span></span><br><span class="line"><span class="string"> * 	poll_table pt;</span></span><br><span class="line"><span class="string">	 * struct epitem *epi;</span></span><br><span class="line"><span class="string"> * &#125;;</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">	struct ep_pqueue epq;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	lockdep_assert_irqs_enabled();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span></span><br><span class="line"><span class="string">	if (unlikely(user_watches &gt;= max_user_watches))</span></span><br><span class="line"><span class="string">		return -ENOSPC;</span></span><br><span class="line"><span class="string">		// slab算法从内存池取一个分配好的epitem</span></span><br><span class="line"><span class="string">	if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span></span><br><span class="line"><span class="string">		return -ENOMEM;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Item initialization follow here ... */</span></span><br><span class="line"><span class="string">	INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span></span><br><span class="line"><span class="string">	INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span></span><br><span class="line"><span class="string">	INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span></span><br><span class="line"><span class="string">	epi-&gt;ep = ep;</span></span><br><span class="line"><span class="string">	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span></span><br><span class="line"><span class="string">	epi-&gt;event = *event;</span></span><br><span class="line"><span class="string">	epi-&gt;nwait = 0;</span></span><br><span class="line"><span class="string">	epi-&gt;next = EP_UNACTIVE_PTR;</span></span><br><span class="line"><span class="string">	if (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span></span><br><span class="line"><span class="string">		error = ep_create_wakeup_source(epi);</span></span><br><span class="line"><span class="string">		if (error)</span></span><br><span class="line"><span class="string">			goto error_create_wakeup_source;</span></span><br><span class="line"><span class="string">	&#125; else &#123;</span></span><br><span class="line"><span class="string">		RCU_INIT_POINTER(epi-&gt;ws, NULL);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Initialize the poll table using the queue callback */</span></span><br><span class="line"><span class="string">	epq.epi = epi; // 将一个epq和新插入的epitem(epi)关联</span></span><br><span class="line"><span class="string">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Attach the item to the poll hooks and get current event bits.</span></span><br><span class="line"><span class="string">	 * We can safely use the file* here because its usage count has</span></span><br><span class="line"><span class="string">	 * been increased by the caller of this function. Note that after</span></span><br><span class="line"><span class="string">	 * this operation completes, the poll callback can start hitting</span></span><br><span class="line"><span class="string">	 * the new item.</span></span><br><span class="line"><span class="string">	 * epi被监听的文件,ep_item_poll返回就绪事件的掩码，赋给revents.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	revents = ep_item_poll(epi, &amp;epq.pt, 1);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * We have to check if something went wrong during the poll wait queue</span></span><br><span class="line"><span class="string">	 * install process. Namely an allocation for a wait queue failed due</span></span><br><span class="line"><span class="string">	 * high memory pressure.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	error = -ENOMEM;</span></span><br><span class="line"><span class="string">	if (epi-&gt;nwait &lt; 0)</span></span><br><span class="line"><span class="string">		goto error_unregister;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Add the current item to the list of active epoll hook for this file */</span></span><br><span class="line"><span class="string">	spin_lock(&amp;tfile-&gt;f_lock);</span></span><br><span class="line"><span class="string">	// 每个文件会将所有监听自己的epitem链起来</span></span><br><span class="line"><span class="string">	list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span></span><br><span class="line"><span class="string">	spin_unlock(&amp;tfile-&gt;f_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Add the current item to the RB tree. All RB tree operations are</span></span><br><span class="line"><span class="string">	 * protected by "mtx", and ep_insert() is called with "mtx" held.</span></span><br><span class="line"><span class="string">	 * 将epitem插入到对应的eventpoll中去</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	ep_rbtree_insert(ep, epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* now check if we'</span>ve created too many backpaths */</span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (full_check &amp;&amp; reverse_path_check())</span><br><span class="line">		goto error_remove_epi;</span><br><span class="line"></span><br><span class="line">	/* We have to drop the new item inside our item list to keep track of it */</span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	/* record NAPI ID of new item <span class="keyword">if</span> present */</span><br><span class="line">	ep_set_busy_poll_napi_id(epi);</span><br><span class="line"></span><br><span class="line">	/* If the file is already <span class="string">"ready"</span> we drop it inside the ready list */</span><br><span class="line">	<span class="keyword">if</span> (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">		/* Notify waiting tasks that events are available */</span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">	/* We have to call this outside the lock */</span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">error_remove_epi:</span><br><span class="line">	spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">	list_del_rcu(&amp;epi-&gt;fllink);</span><br><span class="line">	spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">	rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">error_unregister:</span><br><span class="line">	ep_unregister_pollwait(ep, epi);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We need to <span class="keyword">do</span> this because an event could have been arrived on some</span><br><span class="line">	 * allocated <span class="built_in">wait</span> queue. Note that we don<span class="string">'t care about the ep-&gt;ovflist</span></span><br><span class="line"><span class="string">	 * list, since that is used/cleaned only inside a section bound by "mtx".</span></span><br><span class="line"><span class="string">	 * And ep_insert() is called with "mtx" held.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string">	if (ep_is_linked(epi))</span></span><br><span class="line"><span class="string">		list_del_init(&amp;epi-&gt;rdllink);</span></span><br><span class="line"><span class="string">	write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	wakeup_source_unregister(ep_wakeup_source(epi));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_create_wakeup_source:</span></span><br><span class="line"><span class="string">	kmem_cache_free(epi_cache, epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * mm/slab.cmm/slab.c</span></span><br><span class="line"><span class="string"> * kmem_cache_alloc - Allocate an object</span></span><br><span class="line"><span class="string"> * @cachep: The cache to allocate from.</span></span><br><span class="line"><span class="string"> * @flags: See kmalloc().</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Allocate an object from this cache.  The flags are only relevant</span></span><br><span class="line"><span class="string"> * if the cache has no available objects.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Return: pointer to the new object or %NULL in case of error</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	void *ret = slab_alloc(cachep, flags, _RET_IP_);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	trace_kmem_cache_alloc(_RET_IP_, ret,</span></span><br><span class="line"><span class="string">			       cachep-&gt;object_size, cachep-&gt;size, flags);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ret;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL(kmem_cache_alloc);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * 设置回调</span></span><br><span class="line"><span class="string"> * include/linux/poll.h</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	pt-&gt;_qproc = qproc;</span></span><br><span class="line"><span class="string">	pt-&gt;_key   = ~(__poll_t)0; /* all events enabled */</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * 唤醒时执行的回调函数</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="string"> * target file wakeup lists.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,poll_table *pt)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	struct epitem *epi = ep_item_from_epqueue(pt);</span></span><br><span class="line"><span class="string">	struct eppoll_entry *pwq;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span></span><br><span class="line"><span class="string">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span></span><br><span class="line"><span class="string">		pwq-&gt;whead = whead;</span></span><br><span class="line"><span class="string">		pwq-&gt;base = epi;</span></span><br><span class="line"><span class="string">		if (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span></span><br><span class="line"><span class="string">			add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			add_wait_queue(whead, &amp;pwq-&gt;wait);</span></span><br><span class="line"><span class="string">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span></span><br><span class="line"><span class="string">		epi-&gt;nwait++;</span></span><br><span class="line"><span class="string">	&#125; else &#123;</span></span><br><span class="line"><span class="string">		/* We have to signal that an error occurred */</span></span><br><span class="line"><span class="string">		epi-&gt;nwait = -1;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * Differs from ep_eventpoll_poll() in that internal callers already have</span></span><br><span class="line"><span class="string"> * the ep-&gt;mtx so we need to start from depth=1, such that mutex_lock_nested()</span></span><br><span class="line"><span class="string"> * is correctly annotated.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,</span></span><br><span class="line"><span class="string">				 int depth)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	struct eventpoll *ep;</span></span><br><span class="line"><span class="string">	bool locked;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	pt-&gt;_key = epi-&gt;event.events;</span></span><br><span class="line"><span class="string">	if (!is_file_epoll(epi-&gt;ffd.file))</span></span><br><span class="line"><span class="string">		return vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	ep = epi-&gt;ffd.file-&gt;private_data;</span></span><br><span class="line"><span class="string">	poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span></span><br><span class="line"><span class="string">	locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span></span><br><span class="line"><span class="string">				  ep_read_events_proc, &amp;depth, depth,</span></span><br><span class="line"><span class="string">				  locked) &amp; epi-&gt;event.events;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// include/linux/poll.h</span></span><br><span class="line"><span class="string">static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	if (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span></span><br><span class="line"><span class="string">		p-&gt;_qproc(filp, wait_address, p);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// include/linux/wait.h</span></span><br><span class="line"><span class="string">static inline void init_waitqueue_func_entry(struct wait_queue_entry *wq_entry, wait_queue_func_t func)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	wq_entry-&gt;flags		= 0;</span></span><br><span class="line"><span class="string">	wq_entry-&gt;private	= NULL;</span></span><br><span class="line"><span class="string">	wq_entry-&gt;func		= func;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * This is the callback that is passed to the wait queue wakeup</span></span><br><span class="line"><span class="string"> * mechanism. It is called by the stored file descriptors when they</span></span><br><span class="line"><span class="string"> * have events to report.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * This callback takes a read lock in order not to content with concurrent</span></span><br><span class="line"><span class="string"> * events from another file descriptors, thus all modifications to -&gt;rdllist</span></span><br><span class="line"><span class="string"> * or -&gt;ovflist are lockless.  Read lock is paired with the write lock from</span></span><br><span class="line"><span class="string"> * ep_scan_ready_list(), which stops all list modifications and guarantees</span></span><br><span class="line"><span class="string"> * that lists state is seen correctly.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Another thing worth to mention is that ep_poll_callback() can be called</span></span><br><span class="line"><span class="string"> * concurrently for the same @epi from different CPUs if poll table was inited</span></span><br><span class="line"><span class="string"> * with several wait queues entries.  Plural wakeup from different CPUs of a</span></span><br><span class="line"><span class="string"> * single wait queue is serialized by wq.lock, but the case when multiple wait</span></span><br><span class="line"><span class="string"> * queues are used should be detected accordingly.  This is detected using</span></span><br><span class="line"><span class="string"> * cmpxchg() operation.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int pwake = 0;</span></span><br><span class="line"><span class="string">	struct epitem *epi = ep_item_from_wait(wait);</span></span><br><span class="line"><span class="string">	struct eventpoll *ep = epi-&gt;ep;</span></span><br><span class="line"><span class="string">	__poll_t pollflags = key_to_poll(key);</span></span><br><span class="line"><span class="string">	unsigned long flags;</span></span><br><span class="line"><span class="string">	int ewake = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	read_lock_irqsave(&amp;ep-&gt;lock, flags);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	ep_set_busy_poll_napi_id(epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="string">	 * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="string">	 * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="string">	 * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span></span><br><span class="line"><span class="string">		goto out_unlock;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Check the events coming with the callback. At this stage, not</span></span><br><span class="line"><span class="string">	 * every device reports the events in the "key" parameter of the</span></span><br><span class="line"><span class="string">	 * callback. We need to be able to handle both cases here, hence the</span></span><br><span class="line"><span class="string">	 * test for "key" != NULL before the event match test.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span></span><br><span class="line"><span class="string">		goto out_unlock;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * If we are transferring events to userspace, we can hold no locks</span></span><br><span class="line"><span class="string">	 * (because we'</span>re accessing user memory, and because of linux f_op-&gt;poll()</span><br><span class="line">	 * semantics). All the events that happen during that period of time are</span><br><span class="line">	 * chained <span class="keyword">in</span> ep-&gt;ovflist and requeued later on.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp;</span><br><span class="line">		    chain_epi_lockless(epi))</span><br><span class="line">			ep_pm_stay_awake_rcu(epi);</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* If this file is already <span class="keyword">in</span> the ready list we <span class="built_in">exit</span> soon */</span><br><span class="line">	<span class="keyword">if</span> (!ep_is_linked(epi) &amp;&amp;</span><br><span class="line">	    list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">		ep_pm_stay_awake_rcu(epi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Wake up ( <span class="keyword">if</span> active ) both the eventpoll <span class="built_in">wait</span> list and the -&gt;poll()</span><br><span class="line">	 * <span class="built_in">wait</span> list.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span><br><span class="line">					!(pollflags &amp; POLLFREE)) &#123;</span><br><span class="line">			switch (pollflags &amp; EPOLLINOUT_BITS) &#123;</span><br><span class="line">			<span class="keyword">case</span> EPOLLIN:</span><br><span class="line">				<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLIN)</span><br><span class="line">					ewake = 1;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			<span class="keyword">case</span> EPOLLOUT:</span><br><span class="line">				<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLOUT)</span><br><span class="line">					ewake = 1;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 0:</span><br><span class="line">				ewake = 1;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		wake_up(&amp;ep-&gt;wq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">		pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	/* We have to call this outside the lock */</span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span><br><span class="line">		ewake = 1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pollflags &amp; POLLFREE) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * If we race with ep_remove_wait_queue() it can miss</span><br><span class="line">		 * -&gt;whead = NULL and <span class="keyword">do</span> another remove_wait_queue() after</span><br><span class="line">		 * us, so we can<span class="string">'t use __remove_wait_queue().</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		list_del_init(&amp;wait-&gt;entry);</span></span><br><span class="line"><span class="string">		/*</span></span><br><span class="line"><span class="string">		 * -&gt;whead != NULL protects us from the race with ep_free()</span></span><br><span class="line"><span class="string">		 * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span></span><br><span class="line"><span class="string">		 * held by the caller. Once we nullify it, nothing protects</span></span><br><span class="line"><span class="string">		 * ep/epi or even wait.</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, NULL);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return ewake;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for</span></span><br><span class="line"><span class="string"> *                      the scan code, to call f_op-&gt;poll(). Also allows for</span></span><br><span class="line"><span class="string"> *                      O(NumReady) performance.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @ep: Pointer to the epoll private data structure.</span></span><br><span class="line"><span class="string"> * @sproc: Pointer to the scan callback.</span></span><br><span class="line"><span class="string"> * @priv: Private opaque data passed to the @sproc callback.</span></span><br><span class="line"><span class="string"> * @depth: The current depth of recursive f_op-&gt;poll calls.</span></span><br><span class="line"><span class="string"> * @ep_locked: caller already holds ep-&gt;mtx</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Returns: The same integer error code returned by the @sproc callback.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static __poll_t ep_scan_ready_list(struct eventpoll *ep,</span></span><br><span class="line"><span class="string">			      __poll_t (*sproc)(struct eventpoll *,</span></span><br><span class="line"><span class="string">					   struct list_head *, void *),</span></span><br><span class="line"><span class="string">			      void *priv, int depth, bool ep_locked)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	__poll_t res;</span></span><br><span class="line"><span class="string">	int pwake = 0;</span></span><br><span class="line"><span class="string">	struct epitem *epi, *nepi;</span></span><br><span class="line"><span class="string">	LIST_HEAD(txlist);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	lockdep_assert_irqs_enabled();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="string">	 * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!ep_locked)</span></span><br><span class="line"><span class="string">		mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Steal the ready list, and re-init the original one to the</span></span><br><span class="line"><span class="string">	 * empty list. Also, set ep-&gt;ovflist to NULL so that events</span></span><br><span class="line"><span class="string">	 * happening while looping w/out locks, are not lost. We cannot</span></span><br><span class="line"><span class="string">	 * have the poll callback to queue directly on ep-&gt;rdllist,</span></span><br><span class="line"><span class="string">	 * because we want the "sproc" callback to be able to do it</span></span><br><span class="line"><span class="string">	 * in a lockless way.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string">	list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span></span><br><span class="line"><span class="string">	WRITE_ONCE(ep-&gt;ovflist, NULL);</span></span><br><span class="line"><span class="string">	write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Now call the callback function.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	res = (*sproc)(ep, &amp;txlist, priv);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * During the time we spent inside the "sproc" callback, some</span></span><br><span class="line"><span class="string">	 * other events might have been queued by the poll callback.</span></span><br><span class="line"><span class="string">	 * We re-insert them inside the main ready-list here.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	for (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != NULL;</span></span><br><span class="line"><span class="string">	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span></span><br><span class="line"><span class="string">		/*</span></span><br><span class="line"><span class="string">		 * We need to check if the item is already in the list.</span></span><br><span class="line"><span class="string">		 * During the "sproc" callback execution time, items are</span></span><br><span class="line"><span class="string">		 * queued into -&gt;ovflist but the "txlist" might already</span></span><br><span class="line"><span class="string">		 * contain them, and the list_splice() below takes care of them.</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		if (!ep_is_linked(epi)) &#123;</span></span><br><span class="line"><span class="string">			/*</span></span><br><span class="line"><span class="string">			 * -&gt;ovflist is LIFO, so we have to reverse it in order</span></span><br><span class="line"><span class="string">			 * to keep in FIFO.</span></span><br><span class="line"><span class="string">			 */</span></span><br><span class="line"><span class="string">			list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span></span><br><span class="line"><span class="string">			ep_pm_stay_awake(epi);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span></span><br><span class="line"><span class="string">	 * releasing the lock, events will be queued in the normal way inside</span></span><br><span class="line"><span class="string">	 * ep-&gt;rdllist.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Quickly re-inject items left on "txlist".</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span></span><br><span class="line"><span class="string">	__pm_relax(ep-&gt;ws);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span></span><br><span class="line"><span class="string">		/*</span></span><br><span class="line"><span class="string">		 * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="string">		 * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		if (waitqueue_active(&amp;ep-&gt;wq))</span></span><br><span class="line"><span class="string">			wake_up(&amp;ep-&gt;wq);</span></span><br><span class="line"><span class="string">		if (waitqueue_active(&amp;ep-&gt;poll_wait))</span></span><br><span class="line"><span class="string">			pwake++;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (!ep_locked)</span></span><br><span class="line"><span class="string">		mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* We have to call this outside the lock */</span></span><br><span class="line"><span class="string">	if (pwake)</span></span><br><span class="line"><span class="string">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return res;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * Removes a "struct epitem" from the eventpoll RB tree and deallocates</span></span><br><span class="line"><span class="string"> * all the associated resources. Must be called with "mtx" held.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int ep_remove(struct eventpoll *ep, struct epitem *epi)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	struct file *file = epi-&gt;ffd.file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	lockdep_assert_irqs_enabled();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Removes poll wait queue hooks.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	ep_unregister_pollwait(ep, epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Remove the current item from the list of epoll hooks */</span></span><br><span class="line"><span class="string">	spin_lock(&amp;file-&gt;f_lock);</span></span><br><span class="line"><span class="string">	list_del_rcu(&amp;epi-&gt;fllink);</span></span><br><span class="line"><span class="string">	spin_unlock(&amp;file-&gt;f_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string">	if (ep_is_linked(epi))</span></span><br><span class="line"><span class="string">		list_del_init(&amp;epi-&gt;rdllink);</span></span><br><span class="line"><span class="string">	write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	wakeup_source_unregister(ep_wakeup_source(epi));</span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * At this point it is safe to free the eventpoll item. Use the union</span></span><br><span class="line"><span class="string">	 * field epi-&gt;rcu, since we are trying to minimize the size of</span></span><br><span class="line"><span class="string">	 * '</span>struct epitem<span class="string">'. The '</span>rbn<span class="string">' field is no longer in use. Protected by</span></span><br><span class="line"><span class="string">	 * ep-&gt;mtx. The rcu read side, reverse_path_check_proc(), does not make</span></span><br><span class="line"><span class="string">	 * use of the rbn field.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	call_rcu(&amp;epi-&gt;rcu, epi_rcu_free);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	atomic_long_dec(&amp;ep-&gt;user-&gt;epoll_watches);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 用户空间调用int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// fs/eventpoll.c</span></span><br><span class="line"><span class="string">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,int, maxevents, int, timeout)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	return do_epoll_wait(epfd, events, maxevents, timeout);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * Implement the event wait interface for the eventpoll file. It is the kernel</span></span><br><span class="line"><span class="string"> * part of the user space epoll_wait(2).</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int do_epoll_wait(int epfd, struct epoll_event __user *events,int maxevents, int timeout)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int error;</span></span><br><span class="line"><span class="string">	struct fd f;</span></span><br><span class="line"><span class="string">	struct eventpoll *ep;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* The maximum number of event must be greater than zero */</span></span><br><span class="line"><span class="string">	if (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS)</span></span><br><span class="line"><span class="string">		return -EINVAL;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Verify that the area passed by the user is writeable */</span></span><br><span class="line"><span class="string">	if (!access_ok(events, maxevents * sizeof(struct epoll_event)))</span></span><br><span class="line"><span class="string">		return -EFAULT;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Get the "struct file *" for the eventpoll file */</span></span><br><span class="line"><span class="string">	f = fdget(epfd);</span></span><br><span class="line"><span class="string">	if (!f.file)</span></span><br><span class="line"><span class="string">		return -EBADF;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * We have to check that the file structure underneath the fd</span></span><br><span class="line"><span class="string">	 * the user passed to us _is_ an eventpoll file.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	error = -EINVAL;</span></span><br><span class="line"><span class="string">	if (!is_file_epoll(f.file))</span></span><br><span class="line"><span class="string">		goto error_fput;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * At this point it is safe to assume that the "private_data" contains</span></span><br><span class="line"><span class="string">	 * our own data structure.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	ep = f.file-&gt;private_data;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* Time to fish for events ... */</span></span><br><span class="line"><span class="string">	error = ep_poll(ep, events, maxevents, timeout);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_fput:</span></span><br><span class="line"><span class="string">	fdput(f);</span></span><br><span class="line"><span class="string">	return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * ep_poll - Retrieves ready events, and delivers them to the caller supplied</span></span><br><span class="line"><span class="string"> *           event buffer.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @ep: Pointer to the eventpoll context.</span></span><br><span class="line"><span class="string"> * @events: Pointer to the userspace buffer where the ready events should be</span></span><br><span class="line"><span class="string"> *          stored.</span></span><br><span class="line"><span class="string"> * @maxevents: Size (in terms of number of events) of the caller event buffer.</span></span><br><span class="line"><span class="string"> * @timeout: Maximum timeout for the ready events fetch operation, in</span></span><br><span class="line"><span class="string"> *           milliseconds. If the @timeout is zero, the function will not block,</span></span><br><span class="line"><span class="string"> *           while if the @timeout is less than zero, the function will block</span></span><br><span class="line"><span class="string"> *           until at least one event has been retrieved (or an error</span></span><br><span class="line"><span class="string"> *           occurred).</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Returns: Returns the number of ready events which have been fetched, or an</span></span><br><span class="line"><span class="string"> *          error code, in case of error.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,</span></span><br><span class="line"><span class="string">		   int maxevents, long timeout)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	int res = 0, eavail, timed_out = 0;</span></span><br><span class="line"><span class="string">	u64 slack = 0;</span></span><br><span class="line"><span class="string">	bool waiter = false;</span></span><br><span class="line"><span class="string">	wait_queue_entry_t wait;</span></span><br><span class="line"><span class="string">	ktime_t expires, *to = NULL;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	lockdep_assert_irqs_enabled();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (timeout &gt; 0) &#123; // 等待时间为timeout</span></span><br><span class="line"><span class="string">		struct timespec64 end_time = ep_set_mstimeout(timeout);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		slack = select_estimate_accuracy(&amp;end_time);</span></span><br><span class="line"><span class="string">		to = &amp;expires;</span></span><br><span class="line"><span class="string">		*to = timespec64_to_ktime(end_time);</span></span><br><span class="line"><span class="string">	&#125; else if (timeout == 0) &#123; // 不等待立即返回，-1表示一直等待</span></span><br><span class="line"><span class="string">		/*</span></span><br><span class="line"><span class="string">		 * Avoid the unnecessary trip to the wait queue loop, if the</span></span><br><span class="line"><span class="string">		 * caller specified a non blocking operation. We still need</span></span><br><span class="line"><span class="string">		 * lock because we could race and not see an epi being added</span></span><br><span class="line"><span class="string">		 * to the ready list while in irq callback. Thus incorrectly</span></span><br><span class="line"><span class="string">		 * returning 0 back to userspace.</span></span><br><span class="line"><span class="string">		 */</span></span><br><span class="line"><span class="string">		timed_out = 1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string">		eavail = ep_events_available(ep);</span></span><br><span class="line"><span class="string">		write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		goto send_events;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fetch_events:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 无就绪事件则忙等</span></span><br><span class="line"><span class="string">	if (!ep_events_available(ep))</span></span><br><span class="line"><span class="string">		ep_busy_loop(ep, timed_out);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 存在就绪事件，执行send_events</span></span><br><span class="line"><span class="string">	eavail = ep_events_available(ep);</span></span><br><span class="line"><span class="string">	if (eavail)</span></span><br><span class="line"><span class="string">		goto send_events;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Busy poll timed out.  Drop NAPI ID for now, we can add</span></span><br><span class="line"><span class="string">	 * it back in when we have moved a socket with a valid NAPI</span></span><br><span class="line"><span class="string">	 * ID onto the ready list.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	ep_reset_busy_poll_napi_id(ep);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * We don'</span>t have any available event to <span class="built_in">return</span> to the <span class="built_in">caller</span>.  We need</span><br><span class="line">	 * to sleep here, and we will be woken by ep_poll_callback() when events</span><br><span class="line">	 * become available.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (!waiter) &#123;</span><br><span class="line">		waiter = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">// ep-&gt;rdllist存放的是已就绪(<span class="built_in">read</span>)的fd，为空时说明当前没有就绪的fd，</span><br><span class="line">// 创建一个等待队列项，并使用当前进程（current）初始化</span><br><span class="line">		init_waitqueue_entry(&amp;<span class="built_in">wait</span>, current);</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">// 将当前进程添加到等待队列</span><br><span class="line">		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;<span class="built_in">wait</span>);</span><br><span class="line">		spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * We don<span class="string">'t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="string">		 * a wakeup in between. That'</span>s why we <span class="built_in">set</span> the task state</span><br><span class="line">		 * to TASK_INTERRUPTIBLE before doing the checks.</span><br><span class="line">		 * 将进程状态设置为TASK_INTERRUPTIBLE，</span><br><span class="line">		 * 因为我们不希望这期间ep_poll_callback()发信号唤醒进程的时候，进程还在sleep</span><br><span class="line">		 */</span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		/*</span><br><span class="line">		 * Always short-circuit <span class="keyword">for</span> fatal signals to allow</span><br><span class="line">		 * threads to make a timely <span class="built_in">exit</span> without the chance of</span><br><span class="line">		 * finding more events available and fetching</span><br><span class="line">		 * repeatedly.</span><br><span class="line">		 */</span><br><span class="line">		<span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		eavail = ep_events_available(ep);</span><br><span class="line">		// 如果ep-&gt;rdllist非空(即有就绪的fd)或时间到则跳出循环体</span><br><span class="line">		<span class="keyword">if</span> (eavail)</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span><br><span class="line">			timed_out = 1;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">send_events:</span><br><span class="line">	/*</span><br><span class="line">	 * Try to transfer events to user space. In <span class="keyword">case</span> we get 0 events and</span><br><span class="line">	 * there<span class="string">'s still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="string">	 * more luck.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (!res &amp;&amp; eavail &amp;&amp;</span></span><br><span class="line"><span class="string">	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span></span><br><span class="line"><span class="string">		goto fetch_events;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (waiter) &#123;</span></span><br><span class="line"><span class="string">		spin_lock_irq(&amp;ep-&gt;wq.lock);</span></span><br><span class="line"><span class="string">		//将等待队列项移出等待队列(将当前进程移出)</span></span><br><span class="line"><span class="string">		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span></span><br><span class="line"><span class="string">		spin_unlock_irq(&amp;ep-&gt;wq.lock);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return res;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * ep_events_available - Checks if ready events might be available.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @ep: Pointer to the eventpoll context.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Returns: Returns a value different than zero if ready events are available,</span></span><br><span class="line"><span class="string"> *          or zero otherwise.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static inline int ep_events_available(struct eventpoll *ep)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	return !list_empty_careful(&amp;ep-&gt;rdllist) ||</span></span><br><span class="line"><span class="string">		READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string"> * Busy poll if globally on and supporting sockets found &amp;&amp; no events,</span></span><br><span class="line"><span class="string"> * busy loop will return if need_resched or ep_events_available.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * we must do our busy polling with irqs enabled</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static void ep_busy_loop(struct eventpoll *ep, int nonblock)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	unsigned int napi_id = READ_ONCE(ep-&gt;napi_id);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if ((napi_id &gt;= MIN_NAPI_ID) &amp;&amp; net_busy_loop_on())</span></span><br><span class="line"><span class="string">		napi_busy_loop(napi_id, nonblock ? NULL : ep_busy_loop_end, ep);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// include/linux/types.h</span></span><br><span class="line"><span class="string">struct list_head &#123;</span></span><br><span class="line"><span class="string">	struct list_head *next, *prev;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * fs/eventpoll.c</span></span><br><span class="line"><span class="string"> * Adds a new entry to the tail of the list in a lockless way, i.e.</span></span><br><span class="line"><span class="string"> * multiple CPUs are allowed to call this function concurrently.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Beware: it is necessary to prevent any other modifications of the</span></span><br><span class="line"><span class="string"> *         existing list until all changes are completed, in other words</span></span><br><span class="line"><span class="string"> *         concurrent list_add_tail_lockless() calls should be protected</span></span><br><span class="line"><span class="string"> *         with a read lock, where write lock acts as a barrier which</span></span><br><span class="line"><span class="string"> *         makes sure all list_add_tail_lockless() calls are fully</span></span><br><span class="line"><span class="string"> *         completed.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> *        Also an element can be locklessly added to the list only in one</span></span><br><span class="line"><span class="string"> *        direction i.e. either to the tail either to the head, otherwise</span></span><br><span class="line"><span class="string"> *        concurrent access will corrupt the list.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Returns %false if element has been already added to the list, %true</span></span><br><span class="line"><span class="string"> * otherwise.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static inline bool list_add_tail_lockless(struct list_head *new,struct list_head *head)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	struct list_head *prev;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * This is simple '</span>new-&gt;next = head<span class="string">' operation, but cmpxchg()</span></span><br><span class="line"><span class="string">	 * is used in order to detect that same element has been just</span></span><br><span class="line"><span class="string">	 * added to the list from another CPU: the winner observes</span></span><br><span class="line"><span class="string">	 * new-&gt;next == new.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string">	if (cmpxchg(&amp;new-&gt;next, new, head) != new)</span></span><br><span class="line"><span class="string">		return false;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * Initially -&gt;next of a new element must be updated with the head</span></span><br><span class="line"><span class="string">	 * (we are inserting to the tail) and only then pointers are atomically</span></span><br><span class="line"><span class="string">	 * exchanged.  XCHG guarantees memory ordering, thus -&gt;next should be</span></span><br><span class="line"><span class="string">	 * updated before pointers are actually swapped and pointers are</span></span><br><span class="line"><span class="string">	 * swapped before prev-&gt;next is updated.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	prev = xchg(&amp;head-&gt;prev, new);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/*</span></span><br><span class="line"><span class="string">	 * It is safe to modify prev-&gt;next and new-&gt;prev, because a new element</span></span><br><span class="line"><span class="string">	 * is added only to the tail and new-&gt;next is updated before XCHG.</span></span><br><span class="line"><span class="string">	 */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	prev-&gt;next = new;</span></span><br><span class="line"><span class="string">	new-&gt;prev = prev;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    
    <div>
     
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2019/06/03/epoll-source/">epoll源码分析(基于linux-5.1.4)</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 icoty 的个人博客">icoty</a></p>
  <p><span>发布时间:</span>2019年06月03日 - 12:06</p>
  <p><span>最后更新:</span>2019年06月05日 - 14:06</p>
  <p><span>原始链接:</span><a href="/2019/06/03/epoll-source/" title="epoll源码分析(基于linux-5.1.4)">https://icoty.github.io/2019/06/03/epoll-source/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://icoty.github.io/2019/06/03/epoll-source/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({
          title: "",
          text: '复制成功',
          icon: "success",
          showConfirmButton: true
          });
    });
    });
</script>


      
    </div>

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>打赏狗粮！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="icoty 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="icoty 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/epoll/" rel="tag"><i class="fa fa-tag"></i> epoll</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/25/cs-threadpool-message-queue/" rel="next" title="基于线程池、消息队列和epoll模型实现Client-Server并发架构">
                <i class="fa fa-chevron-left"></i> 基于线程池、消息队列和epoll模型实现Client-Server并发架构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="icoty">
            
              <p class="site-author-name" itemprop="name">icoty</p>
              <div class="site-description motion-element" itemprop="description">后台 / 系统</div>
          </div>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/icoty" title="GitHub &rarr; https://github.com/icoty" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/icoty23" title="博客园 &rarr; https://www.cnblogs.com/icoty23" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-spinner"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/qq_36347375" title="CSDN &rarr; https://blog.csdn.net/qq_36347375" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-copyright"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:icoty.yangy@gmail.com" title="E-mail &rarr; mailto:icoty.yangy@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://laibh.top" title="http://laibh.top" rel="external nofollow noopener noreferrer" target="_blank">赖同学</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核数据结构"><span class="nav-number">2.</span> <span class="nav-text">内核数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局调用关系"><span class="nav-number">3.</span> <span class="nav-text">全局调用关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll模块初始化-amp-内存池开辟"><span class="nav-number">4.</span> <span class="nav-text">epoll模块初始化&amp;内存池开辟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-create"><span class="nav-number">5.</span> <span class="nav-text">epoll_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">6.</span> <span class="nav-text">epoll_ctl</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="20" width="270" height="42" src="//music.163.com/outchain/player?type=0&id=2768835095&auto=0&height=32"></iframe>

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">icoty</span>

  

  
</div>










        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'zWlHCMwekbEgyjRmAxWLoIR4-gzGzoHsz',
    appKey: 'LbfEX3cmne22ibHj9hcwButY',
    placeholder: '欢迎探讨，留下你的邮箱能够收到我的回复喔！',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  

  

  

  

  

  

  

  

  

</body>
</html>

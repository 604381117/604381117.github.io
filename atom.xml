<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阳光沥肩头 仿佛自由人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-23T01:44:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>icoty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker最简教程</title>
    <link href="http://yoursite.com/2019/04/22/docker/"/>
    <id>http://yoursite.com/2019/04/22/docker/</id>
    <published>2019-04-22T12:49:16.000Z</published>
    <updated>2019-04-23T01:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在让你用最短的时间弄懂Docker命令操作，什么虚拟化都太泛泛了，不讲大道理，实践出真知，让你从此的日常开发和工作中在面对Docker时不再茫然失措而是得心应手。本文也不谈安装，我实在认为作为程序员，要是我在这里教你如何安装Docker，既是在浪费你的时间也是在浪费我的时间，请参考<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">Docker安装</a>；</p><p>Docker Hub是Docker官方维护的一个公共仓库，其中已经包括了数量超过15 000 的镜像，开发者可以注册自己的账号，并自定义自己的镜像进行存储，需要的时候可以直接拿来用，同时也能够分享，有点类似于Github，如想注册可移步 <a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>，注册与否不影响接下来的操作。</p><h3 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h3><p>我认为只要你不是专门研究这个的，那么你只需学会如何使用Docker的一些基本命令，使自己的日常开发和工作不受阻碍，弄清Docker和容器之间的区别，为什么现在很多企业流行Docker，这个东西解决了啥问题，有啥优势就够了。关于Docker是什么有何优势，这里挑了一个简洁的<a href="https://blog.csdn.net/shnsuohaonan/article/details/80651439" target="_blank" rel="noopener">博客链接</a>。</p><p>接下来从零开始，首先从docker hub仓库上拉取centos镜像，带你走进docker日常命令，学会这些命令，足以应对你的日常开发和工作中关于docker的问题。</p><p>search: 从docker hub仓库搜索带centos的所有镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> seach centos</span><br></pre></td></tr></table></figure></p><p>images: 查看本地所有镜像，pull前左侧REPOSITORY栏无centos。REPOSITORY表示镜像被归入到本地的仓库，比如icoty1/lamp:v1.0.0表示本地icoty1仓库下有一个镜像名为lamp,其TAG(版本)为v1.0.0，每个镜像有一个IMAGE ID唯一标识该镜像，SIZE为镜像大小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> images</span><br></pre></td></tr></table></figure></p><p>pull: 从docker hub远程仓库把centos镜像拉到本地，pull后再次执行images，会发现centos已经被拉到本地。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> pull centos</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/search.png" alt="cmd"></p><p>ps: 只列出正在运行的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> ps</span><br></pre></td></tr></table></figure></p><p>ps -a: 列出所有容器, 每一个容器有一个CONTAINER ID唯一标识该容器；IMAGE表示该容器是基于哪个镜像生成的，COMMAND是容器启动时执行的命令，可以传入也可以不传入；STATUS是容器当前的状态，Exit是已停止，Up是正在运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> ps -a</span><br></pre></td></tr></table></figure></p><p>run: 从镜像衍生一个新的容器并运行；-d后台模式运行容器，-i交互模式运行容器；-p把主机80关口映射到容器的80端口，因为容器具有封闭性，容器外部不能直接访问容器内部的端口，通过映射后，主机80端口收到数据后会转发到容器内部的80端口，不过在容器内是可以直接访问容器外的主机的；-v把主机的/Users/yangyu/ide/LeetCode/目录映射到容器的/LeetCode/，容器内若无/LeetCode/目录会自动创建，用于实现主机和容器之间的目录共享，在两个目录下操作文件是对等的；centos:latest是镜像名称，可以换成IMAGE ID，二者等价；/bin/bash是容器启动时执行的命令，还可以带参数，这个不懂的可以搜索下。执行docker run后再次执行ps命令，能够看到运行中的容器多了一个。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> run -d -ti -p 80:80 -v /Users/yangyu/ide/LeetCode/:/LeetCode/ centos:latest /bin/bash</span><br></pre></td></tr></table></figure></p><p>cp: 拷贝主机/Users/yangyu/ide/LeetCode/Database/目录到容器eaf43b370eb7根目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> cp /Users/yangyu/ide/LeetCode/Database/ eaf43b370eb7:/</span><br></pre></td></tr></table></figure></p><p>exec: 执行该命令进入容器eaf43b370eb7内，进入容器后在容器内/LeetCode/目录下新建readme.py2，在主机/Users/yangyu/ide/LeetCode/目录下能够看到该文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it eaf43b370eb7 /bin/bash</span><br><span class="line"><span class="variable">$cp</span> /LeetCode/readme.py /LeetCode/readme.py2</span><br></pre></td></tr></table></figure></p><p>cp: 从容器eaf43b370eb7根目录下拷贝目录/Database到主机的/Users/yangyu/ide/LeetCode/Database/目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> cp eaf43b370eb7:/Database/ /Users/yangyu/ide/LeetCode/Database/</span><br></pre></td></tr></table></figure></p><p>stop/restart: 停止容器eaf43b370eb7然后查看其状态变为Exited；然后通过restart命令重启，容器又处于运行态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> stop eaf43b370eb7</span><br><span class="line"><span class="variable">$docker</span> restart eaf43b370eb7</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/cp-ps-start.png" alt="cmd"></p><p>tag: 把centos镜像归入icoty1仓库下名称为centos，TAG为7，TAG随你定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> tag centos icoty1/centos:7</span><br></pre></td></tr></table></figure></p><p>commit: 最初pull下来的centos镜像是最简版本，里面没有安装mysql vim等；最初pull下来后基于其运行一个容器，你在容器内部可以安装你需要的环境，比如mysql，apache，nginx，hexo博客等，安装好后通过commit命令把容器提交为一个新的镜像，以后凡是从这个新的镜像运行的容器都带有你安装的内容。-m是提交说明；-p是执行commit命令时暂停该容器；eaf43b370eb7是容器ID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> commit -m <span class="string">"提交我的自定义镜像，centos7内安装mysql，版本号v1.0.0"</span> -p eaf43b370eb7 icoty1/centos7-mysql:v1.0.0</span><br></pre></td></tr></table></figure></p><p>save: 把镜像03cb190015bf打包成主机目录/Users/yangyu/ide/LeetCode/下的centos7-mysql.tar，然后你可以通过U盘拷贝到其他机器上，在其他机器上通过load命令可以把centos7-mysql.tar加载成一个镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> save 03cb190015bf &gt; /Users/yangyu/ide/LeetCode/centos7-mysql.tar</span><br></pre></td></tr></table></figure></p><p>load: 把centos7-mysql.tar加载为镜像，因为这个包是从我主机上的镜像03cb190015bf打出来的，所以执行load的时候直接返回镜像03cb190015bf，如果在其他机器上执行会生成一个新的镜像ID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> load &lt; /Users/yangyu/ide/LeetCode/centos7-mysql.tar</span><br></pre></td></tr></table></figure></p><p>push:  把本地icoty1仓库下TAG为v1.0.0的镜像icoty1/centos7-mysql推到远程仓库docker hub上的icoty1仓库下保存，执行push前需要在本地icoty1已经登陆。push成功之后，其他人就可以通过pull命令拉取你的镜像使用了，相当于git clone操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> push icoty1/centos7-mysql:v1.0.0</span><br><span class="line"><span class="variable">$docker</span> pull icoty1/centos7-mysql:v1.0.0</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/load-save.png" alt="cmd"></p><p>rm: 删除容器eaf43b370eb7，运行中的容器无法删除。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> rm eaf43b370eb7</span><br></pre></td></tr></table></figure></p><p>rmi: 删除镜像03cb190015bf，在这之前必须删除由该镜像衍生出来的所有容器删除，否则会删除失败，执行该命令后通过images发现镜像已经没有了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> rmi 03cb190015bf</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/rmi-rm.png" alt="cmd"></p><p>build: 如下以我搭建hexo博客的Dockerfile举例说明。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像，icoty1/ubuntu-hexo-blog:latest在本地仓库必须已经存在</span></span><br><span class="line">FROM icoty1/ubuntu-hexo-blog:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护人员信息，可写可不写</span></span><br><span class="line">MAINTAINER icoty1 <span class="string">"https://icoty.github.io"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露容器的4000端口，这样主机就可以映射端口到4000了</span></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line">/*自动安装所需环境，可替换成安装mysql vim等你需要的命令</span><br><span class="line"> *hexo部分插件安装，使支持rss，图片，字数统计等功能</span><br><span class="line"> */</span><br><span class="line">RUN npm install -g hexo-cli \</span><br><span class="line">&amp;&amp; npm install hexo-server --save \</span><br><span class="line">&amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> /blog \</span><br><span class="line">&amp;&amp; npm install \</span><br><span class="line">&amp;&amp; npm install hexo-deployer-git --save \</span><br><span class="line">&amp;&amp; npm install hexo-migrator-rss --save \ </span><br><span class="line">&amp;&amp; npm install hexo-asset-image --save\</span><br><span class="line">&amp;&amp; npm install hexo-wordcount --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-sitemap --save \ </span><br><span class="line">&amp;&amp; npm install hexo-generator-baidu-sitemap --save \ </span><br><span class="line">&amp;&amp; npm install hexo-helper-live2d --save \</span><br><span class="line">&amp;&amp; git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia \</span><br><span class="line">&amp;&amp; sed <span class="string">"s/theme: landscape/theme: yilia/g"</span> -i /blog/_config.yml</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t icoty1/ubuntu-hexo . <span class="comment"># icoty1/ubuntu-hexo是新的镜像的名字</span></span><br><span class="line">$ docker images <span class="comment"># build后会多出icoty1/ubuntu-hexo镜像</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/22/docker/build.png" alt="cmd"></p><h3 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h3><p>为了便于理解，你可以把镜像理解成一个初始模版A，通过这个模板A你可以复制出模板B、模板C等，模板B和模板C在这里就相当于容器，突然某一天你发现模板A现有的内容已经不能满足你的需求了（比如模板A没有安装Mysql，而你需要安装Mysql），这时你就只能自定义新的模板(相当于自定义新的符合你的要求的镜像)，而自定义方式则可以从模板B或模板C中安装Mysql，安装成功之后，通过docker commit命令将模板B或模板C提交成一个新的初始模板A1（也就是新的镜像），以后所有从模板A1运行的容器就都有Mysql了，然后你就有模板A和模板A1了（就是两个镜像）。</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>实际操作部分，对各个命令有疑问的，相信我，直接执行一遍才是解决你心中疑虑的不二之法，如果你的命令参数不正确，顶多就是报错和执行不成功，不会让你的主机崩溃，最坏也就不过重新执行一遍，IT这个职业，其本身就是一个不断试错、犯错和总结经验的过程，如果你学到了，请我喝奶茶吧，小生会一直奋斗在原创的路上。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker命令</a><br><a href="http://www.docker.org.cn/index.html" target="_blank" rel="noopener">Docker中文社区</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文旨在让你用最短的时间弄懂Docker命令操作，什么虚拟化都太泛泛了，不讲大道理，实践出真知，让你从此的日常开发和工作中在面对Docker时不再茫然失措而是得心应手。本文也不谈安装，我实在认为作为程序员，要是我在这里教你如何安装Docker，既是在浪费你的时间也是在浪费我
      
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="Dockerfile" scheme="http://yoursite.com/tags/Dockerfile/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github博客最简教程-Dockerfile自动搭建</title>
    <link href="http://yoursite.com/2019/04/18/docker-hexo-blog/"/>
    <id>http://yoursite.com/2019/04/18/docker-hexo-blog/</id>
    <published>2019-04-18T15:23:05.000Z</published>
    <updated>2019-04-23T01:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h3><p>拿出你的气质，打开你的电脑，借你半小时搭建好属于你的hexo博客，小生用dockerfile自动帮你搭建好；<br>你只需要在你的mac或linux或windows上提前把docker安装好，如何安装不是我的重点，请参考<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">Docker安装</a>；<br>作为程序员，博客就像你的影子，我都已经忘了内心曾经多少次告诫自己，一定要搭建一个属于自己的技术博客，奈何日复一日过去了，近来终于落实到行动上来，所谓明日复明日，明日何其多，早晚要做的事，劝君晚做不如早做。</p><h3 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h3><h4 id="获取基础镜像"><a href="#获取基础镜像" class="headerlink" title="获取基础镜像"></a>获取基础镜像</h4><p>Docker安装成功之后方能进行接下来的操作，首先从我的Docker Hub仓库上获取基础镜像</p><p><img src="/2019/04/18/docker-hexo-blog/dockerhub.png" alt="docker hub"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull icoty1/ubuntu-hexo-blog <span class="comment"># 从Docker hub上的icoty1用户下获取基础镜像</span></span><br><span class="line">$ docker images <span class="comment"># 查看本地所有镜像，会发现icoty1/ubuntu-hexo-blog已经被pull下来了</span></span><br></pre></td></tr></table></figure><h4 id="生成Dockerfile"><a href="#生成Dockerfile" class="headerlink" title="生成Dockerfile"></a>生成Dockerfile</h4><p>进入一个空的目录下新建空文件Dockerfile，复制如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM icoty1/ubuntu-hexo-blog:latest</span><br><span class="line"></span><br><span class="line">MAINTAINER icoty1 <span class="string">"https://icoty.github.io"</span> </span><br><span class="line"></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo部分插件安装，使支持rss，图片，字数统计等功能</span></span><br><span class="line">RUN npm install -g hexo-cli \</span><br><span class="line">&amp;&amp; npm install hexo-server --save \</span><br><span class="line">&amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> /blog \</span><br><span class="line">&amp;&amp; npm install \</span><br><span class="line">&amp;&amp; npm install hexo-deployer-git --save \</span><br><span class="line">&amp;&amp; npm install hexo-migrator-rss --save \</span><br><span class="line">&amp;&amp; npm install hexo-asset-image --save\</span><br><span class="line">&amp;&amp; npm install hexo-wordcount --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-baidu-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-helper-live2d --save \</span><br><span class="line">&amp;&amp; git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia \</span><br><span class="line">&amp;&amp; sed <span class="string">"s/theme: landscape/theme: yilia/g"</span> -i /blog/_config.yml</span><br></pre></td></tr></table></figure><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>Dockerfile中的最后两行内容表示的含义是从github上把hexo-theme-yilia克隆下来并重命名成yilia，然后放到容器的/blog/themes/目录下，其中hexo-theme-yilia是hexo的主题，hexo有很多种主题，用每一种主题搭建出来的hexo博客界面美观和布局都不尽相同，你可以通过<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网</a>上浏览每一种主题长啥样子，通过<a href="https://github.com/search?q=hexo-theme" target="_blank" rel="noopener">github</a>获取主题的源码仓库，选择一个你喜欢的主题，并相应的修改这两行。假如你从github选择的主题仓库地址是<a href="https://github.com/yscoder/hexo-theme-indigo.git" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo.git</a> ， 那么你需要按照如下方式进行修改，如果你就想用yilia，那么你不需要做任何修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo.git themes/indigo \</span><br><span class="line">&amp;&amp; sed <span class="string">"s/theme: landscape/theme: indigo/g"</span> -i /blog/_config.yml</span><br></pre></td></tr></table></figure><h4 id="构建Hexo镜像"><a href="#构建Hexo镜像" class="headerlink" title="构建Hexo镜像"></a>构建Hexo镜像</h4><p>在Dockerfile的同级目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t icoty1/ubuntu-hexo .  <span class="comment"># 把icoty1/ubuntu-hexo替换成你取的名字</span></span><br><span class="line">$ docker images <span class="comment"># 能够看到多出一条记录icoty1/ubuntu-hexo，并能看到该镜像的[IMAGE ID]</span></span><br></pre></td></tr></table></figure><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 把[IMAGE ID]替换成上一步构建出来的镜像的ID，该句执行成功会多出来一个容器并有一个[CONTAINER ID]</span><br><span class="line"> * -v /home/yangyu/blog/：/blog/是把本机的/home/yangyu/blog/目录映射到容器的/blog/目录</span><br><span class="line"> * 通过目录映射，你只需要在本机编辑/home/yangyu/blog/目录下的文件，而不用每次都进入容器/blog/目录下编辑文件</span><br><span class="line"> * -p 4000:4000 将主机的4000端口映射到容器的4000端口</span><br><span class="line"> *\</span><br><span class="line">$ docker run -d -ti -p 4000:4000 -v /home/yangyu/blog/：/blog/ [IMAGE ID] /bin/bash </span><br><span class="line">$ docker ps -a<span class="comment"># 执行该句列出当前所有的容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it [CONTAINER ID] /bin/bash <span class="comment"># 根据前一步的容器ID进入该容器内部</span></span><br><span class="line">$ <span class="built_in">cd</span> /blog/ &amp;&amp; hexo s <span class="comment"># 进入容器内部的/blog/目录下，启动hexo</span></span><br></pre></td></tr></table></figure><h4 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h4><p>浏览器访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，出现下图说明已经成功，以后你的博客配置，文章撰写和发布等，都在/home/yangyu/blog/目录下进行，这和在容器内部/blog/目录下操作完全对等。</p><p><img src="/2019/04/18/docker-hexo-blog/yilia.png" alt="yilia"></p><h3 id="Hexo部署到Github"><a href="#Hexo部署到Github" class="headerlink" title="Hexo部署到Github"></a>Hexo部署到Github</h3><p><a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">注册Github账户</a>，如果已经注册，跳过此步；<br>在github上仓库“用户名.github.io”，比如我的用户名为icoty，仓库名则为：icoty.github.io；</p><p><img src="/2019/04/18/docker-hexo-blog/github.png" alt="yilia"></p><p>执行如下命令生成ssh key，执行完后复制~/.sshid_rsa.pub文件内的全部内容，按照图示添加ssh keys，并粘贴保存到Key栏中，Title栏随便取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span> <span class="comment"># 全程回车</span></span><br><span class="line">$ git config --global user.name <span class="string">"你用github用户名"</span></span><br><span class="line">$ git config --global user.email <span class="string">"你的github邮箱地址"</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/18/docker-hexo-blog/ssh-key.png" alt="yilia"></p><p><img src="/2019/04/18/docker-hexo-blog/add-key.png" alt="yilia"></p><h3 id="配置Hexo主题"><a href="#配置Hexo主题" class="headerlink" title="配置Hexo主题"></a>配置Hexo主题</h3><p>编辑/blog/_config.yml文件，编辑标题、描述信息、Github信息，下图参见我的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 阳光沥肩头 仿佛自由人 <span class="comment"># 标题</span></span><br><span class="line">subtitle: <span class="comment"># 子标题</span></span><br><span class="line">description: Linux C++服务端 <span class="comment"># 描述信息</span></span><br><span class="line">keywords: </span><br><span class="line">author: icoty</span><br><span class="line">language: zh-CN <span class="comment"># 语言</span></span><br><span class="line">timezone: <span class="comment"># 时区</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  - <span class="built_in">type</span>: git</span><br><span class="line">    repository: git@github.com:icoty/icoty.github.io.git  <span class="comment"># 设置repository对应的链接</span></span><br><span class="line">    branch: master                                        <span class="comment"># 设置提交到的分支</span></span><br><span class="line">    message: Site updated at &#123;&#123; now(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>) &#125;&#125; <span class="comment"># 设置我们提交的信息</span></span><br></pre></td></tr></table></figure><p>执行如下命令发布到github上，通过“https://你的github用户名.github.io”访问，我的是<a href="https://icoty.github.io" target="_blank" rel="noopener">https://icoty.github.io</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> generate</span><br><span class="line"><span class="variable">$hexo</span> deploy <span class="comment"># 部署到GitHub</span></span><br></pre></td></tr></table></figure><p>编辑/blog/themes/yilia/_config.yml文件，自定义其他配置，如友链、评论、分享、头像等，这些配置并不是一定要做，做不做都行，只是配置的完善些，你的Hexo博客界面看起来美观些，如何配置在此不一一赘述，请自行查看对应主题的官方文档和Github说明。如果你能操作这里，说明我这个教程还是有效的，感谢你的坚持！</p><h3 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo命令</a></h3><p>Hexo搭建好后，你可以写博客发布到GitHub 上，别人通过“https://你的github用户名.github.io”就能访问你的博客和看到你写的文章，而这个章节就是教你怎么在本地写你的博客，写博客用的MarkDown语法，推荐你安装MarkDown编辑器Typora。下面列出写博客过程中常用的命令，这些命令都需要走到/blog/目录下执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> new <span class="string">"my-hexo"</span> <span class="comment">#新建my-hexo文章，在/blog/source/_post/目录下生成my-hexo.md，在这个文件里面写你的文章</span></span><br><span class="line"><span class="variable">$hexo</span> generate <span class="comment"># 文章写好后保存，然后执行这条命令，生成静态页面至public目录</span></span><br><span class="line"><span class="variable">$hexo</span> s <span class="comment"># 然后开启预览访问端口（默认端口4000，'ctrl+c'关闭server，‘ctrl+z’放到后台运行），通过http://localhost:4000 查看效果，如果满意就执行下一条命令发布到github</span></span><br><span class="line"><span class="variable">$hexo</span> deploy <span class="comment"># 发布到github，通过https://你用github用户名.github.io 访问</span></span><br><span class="line"><span class="variable">$hexo</span> clean <span class="comment"># 有时你写文章和配置其他内容后，老是不生效，就执行下该命令清除缓存文件 (db.json) 和已生成的静态文件 (public)，不是删除，你的文章仍然在的</span></span><br><span class="line"><span class="variable">$nohup</span> hexo s &amp; <span class="comment"># 启动hexo以后台方式运行</span></span><br><span class="line"><span class="variable">$hexo</span> new page <span class="string">"About"</span> <span class="comment">#新建About页面，这个是配置Hexo界面多出来一个About布局</span></span><br><span class="line"><span class="variable">$hexo</span> <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line"><span class="variable">$hexo</span> version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><h3 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">MarkDown语法</a></h3><p>这个比较基础，网上教程也一大堆，MarkDown很容易学，放心比九九表容易多了，只要你用markdown实际动手写过一篇博文后就上手了，因此没啥可说的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;闲谈&quot;&gt;&lt;a href=&quot;#闲谈&quot; class=&quot;headerlink&quot; title=&quot;闲谈&quot;&gt;&lt;/a&gt;闲谈&lt;/h3&gt;&lt;p&gt;拿出你的气质，打开你的电脑，借你半小时搭建好属于你的hexo博客，小生用dockerfile自动帮你搭建好；&lt;br&gt;你只需要在你的mac或l
      
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Dockerfile" scheme="http://yoursite.com/tags/Dockerfile/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信-利用共享内存和管道通信实现聊天窗口</title>
    <link href="http://yoursite.com/2019/04/18/ipc-chat/"/>
    <id>http://yoursite.com/2019/04/18/ipc-chat/</id>
    <published>2019-04-18T00:16:06.000Z</published>
    <updated>2019-04-23T01:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h3><ol><li>A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据通过共享内存传递给B1进程显示；</li><li>对于A、B 进程，采用ctrl+c（实际为SIGINT信号）方式退出，A、B进程通过捕捉SIGINT信号注册信号处理函数进行资源清理，A1、B1进程手动关闭即可。<br><img src="/2019/04/18/ipc-chat/windows.png" alt="聊天窗口模型"></li></ol><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>A、B通过管道通信，如果首先通过ctrl+c退出A进程，那么B进程的fifo1管道的写端会收到SIGPIPE信号而终止B进程，因此必须在B进程终止前清理掉被B占用的共享内存2，将共享内存2的引用计数减一，否则，当B1进程退出并清理共享内存2后，共享内存2的引用计数不为0，会导致共享内存2得不到释放；</li><li>为了解决前一个问题，A、B进程在启动后立即将各自的进程id通过管道发送给对方，并在各自的进程退出时向对方进程id发送SIGINT信号，触发对方进程进入信号处理接口执行资源回收工作；</li><li>A和A1通过共享内存1通信，会从A进程和A1进程的虚拟地址空间分配一段连续的页映射到同一块连续的物理内存页上，这样A、A1两个进程都可以间接访问物理内存页，从而达到通信的目的，一般共享内存需要进行保护，读写不能同时进行，也不能同时进行写操作，共享内存省去了从内核缓冲区到用户缓冲区的拷贝，因此效率高。</li></ol><h3 id="编码与效果图"><a href="#编码与效果图" class="headerlink" title="编码与效果图"></a>编码与效果图</h3><p><img src="/2019/04/18/ipc-chat/ret.png" alt="运行结果"></p><p>func.h:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;strings.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netdb.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/uio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br></pre></td></tr></table></figure></p><p>processA.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int shmid;</span><br><span class="line">int pidB;// 存放对端进程B的进程id号</span><br><span class="line">char *p;// 共享内存指针</span><br><span class="line"></span><br><span class="line">// 回收共享内存资源前先杀死对端进程，否则回收失败</span><br><span class="line">void handle(int num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">kill</span>(pidB, SIGINT);</span><br><span class="line">shmdt(p);</span><br><span class="line">int ret;</span><br><span class="line"><span class="keyword">if</span>(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> (void)-1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, handle);</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666)))  </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管道文件为单工通信方式，因此需要建立两条管道</span><br><span class="line">// A进程通过管道文件fifo1的读端fdr读取B进程发送的数据</span><br><span class="line">// A进程通过管道文件fifo2的写端fdw向B进程发送数据</span><br><span class="line">int fdr, fdw;</span><br><span class="line"><span class="keyword">if</span>(-1 == (fdr=open(<span class="string">"fifo1"</span>, O_RDONLY)) || -1 == (fdw=open(<span class="string">"fifo2"</span>, O_WRONLY)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open fifo1 or open fifo2"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通信之前先通过管道互相告知对方自己的进程id</span><br><span class="line">char s1[10] = &#123;0&#125;;</span><br><span class="line">char s2[10] = &#123;0&#125;;</span><br><span class="line">sprintf(s1, <span class="string">"%d\n"</span>, getpid());</span><br><span class="line">write(fdw, s1, strlen(s1) - 1);</span><br><span class="line"><span class="built_in">read</span>(fdr, s2, strlen(s1) - 1);</span><br><span class="line">pidB = atoi(s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe connect success, A to A1 shmid:[%d], pidA:[%d], pidB:[%d]\n"</span>, shmid, getpid(), pidB);</span><br><span class="line"></span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int ret;</span><br><span class="line">fd_set rdset;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(0, &amp;rdset);</span><br><span class="line">FD_SET(fdr, &amp;rdset);</span><br><span class="line"><span class="keyword">if</span>((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0))</span><br><span class="line">&#123;</span><br><span class="line">// fdr可读,则接收数据之后通过共享内存传给A1</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fdr, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">strncpy(p, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标准输入可读,读出来传递给B进程</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(0, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(STDIN_FILENO, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">write(fdw, buf, strlen(buf) - 1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fdr);</span><br><span class="line">close(fdw);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processB.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int shmid;</span><br><span class="line">int pidA;// 存放对端进程id</span><br><span class="line">char *p;// 共享内存指针</span><br><span class="line"></span><br><span class="line">// 回收共享内存资源前先杀死对端进程，否则回收失败</span><br><span class="line">void handle(int num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">kill</span>(pidA, SIGINT);</span><br><span class="line">shmdt(p);</span><br><span class="line">int ret;</span><br><span class="line"><span class="keyword">if</span>(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> (void)-1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, handle);</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管道文件为单工通信方式</span><br><span class="line">// B进程通过管道文件fifo1的写端fdw向A进程发送数据</span><br><span class="line">// B进程通过管道文件fifo2的读端fdr接收A进程的数据</span><br><span class="line">int fdr, fdw;</span><br><span class="line"><span class="keyword">if</span>(-1 == (fdw=open(<span class="string">"fifo1"</span>, O_WRONLY)) || -1 == (fdr=open(<span class="string">"fifo2"</span>, O_RDONLY)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open fifo1 or open fifo2"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通信之前先通过管道互相告知对方自己的进程id</span><br><span class="line">char s1[10] = &#123;0&#125;;</span><br><span class="line">char s2[10] = &#123;0&#125;;</span><br><span class="line">sprintf(s1, <span class="string">"%d\n"</span>, getpid());</span><br><span class="line">write(fdw, s1, strlen(s1) - 1);</span><br><span class="line"><span class="built_in">read</span>(fdr, s2, strlen(s1) - 1);</span><br><span class="line">pidA = atoi(s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe connect success, B to B1 shmid:[%d], pidA:[%d], pidB:[%d]\n"</span>, shmid, pidA, getpid());</span><br><span class="line"></span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int ret;</span><br><span class="line">fd_set rdset;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(0, &amp;rdset);</span><br><span class="line">FD_SET(fdr, &amp;rdset);</span><br><span class="line"><span class="keyword">if</span>((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0))</span><br><span class="line">&#123;</span><br><span class="line">// fdr可读,则接收数据之后通过共享内存传给B1</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fdr, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">strncpy(p, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标注输入可读,读出来传递给A进程</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(0, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(STDIN_FILENO, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">write(fdw, buf, strlen(buf) - 1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fdr);</span><br><span class="line">close(fdw);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processA1.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "fuprintf("p:%s\n", p);nc.h"</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int shmid;</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p;</span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(strcmp(buf, p)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">// 共享内存有数据可读</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line">strcpy(buf, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I am A1, recv from A:[%s]\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(-1 ==(shmctl(shmid, IPC_RMID, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processB1.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int shmid;</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p;</span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(strcmp(buf, p)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">// 共享内存有数据可读</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line">strcpy(buf, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I am B1, recv from B:[%s]\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(-1 ==(shmctl(shmid, IPC_RMID, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h3><ol><li>这里首先通过ctrl+c退出A进程，然后B进程收到SIGPIPE信号退出，A、B进程同时调用各自的信号处理函数回收资源，通过ipcs命令发现拥有者为root的共享内存资源的nattch都为1，分别被A1和B1占有。</li><li>然后手动关闭A1、B1进程，再次执行ipcs命令，发现拥有者为root的共享内存资源不存在，已经释放成功。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs  <span class="comment"># 查看共性内存资源数量</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/04/18/ipc-chat/ipcs.png" alt="资源回收图"></p><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><p>本文所有<a href="https://github.com/icoty/Linux/tree/master/IPC/chat" target="_blank" rel="noopener">源码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题模型&quot;&gt;&lt;a href=&quot;#问题模型&quot; class=&quot;headerlink&quot; title=&quot;问题模型&quot;&gt;&lt;/a&gt;问题模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据
      
    
    </summary>
    
      <category term="Programing" scheme="http://yoursite.com/categories/Programing/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="IPC" scheme="http://yoursite.com/tags/IPC/"/>
    
      <category term="共享内存" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
      <category term="命名管道" scheme="http://yoursite.com/tags/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    
      <category term="信号" scheme="http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="Select" scheme="http://yoursite.com/tags/Select/"/>
    
  </entry>
  
  <entry>
    <title>Linux下Docker快速部署LAMP</title>
    <link href="http://yoursite.com/2019/04/16/docker-lamp/"/>
    <id>http://yoursite.com/2019/04/16/docker-lamp/</id>
    <published>2019-04-16T15:23:05.000Z</published>
    <updated>2019-04-23T01:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>若你的mac或Linux环境上未安装Docker，请移步<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">Docker安装</a>，确认安装成功之后再进行下文内容。完全不了解Docker的参见我<a href="https://icoty.github.io/2019/04/18/docker-hexo-blog/" target="_blank" rel="noopener">另一篇文章</a>.</p><h3 id="获取基础镜像"><a href="#获取基础镜像" class="headerlink" title="获取基础镜像"></a>获取基础镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull tutum/lamp  <span class="comment"># 从Docker Hub上的tutum用户的仓库获取lamp镜像</span></span><br><span class="line">$ docker images  <span class="comment"># 列出所有的镜像，会发现多一条记录：tutum/lamp</span></span><br></pre></td></tr></table></figure><p>本文用的镜像源<a href="https://hub.docker.com/r/tutum/lamp" target="_blank" rel="noopener">tutum/lamp</a>，目前Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像，开发者可以注册自己的账号，并自定义自己的镜像进行存储，需要的时候可以直接拿来用，同时也能够分享，有点类似于Github。如想注册可移步 <a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>。</p><h3 id="自定义你的镜像"><a href="#自定义你的镜像" class="headerlink" title="自定义你的镜像"></a>自定义你的镜像</h3><p>在一个空的目录下新建Dockerfile文件名，填入如下4行内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM tutum/lamp:latest  <span class="comment"># 表示在镜像tutum/lamp:latest之上自定义你的镜像</span></span><br><span class="line">RUN rm -fr /app  <span class="comment"># 后面会把你的php项目映射到容器的/app/目录下</span></span><br><span class="line">EXPOSE 80 3306   <span class="comment"># 暴露80 3306端口</span></span><br><span class="line">CMD [<span class="string">"/run.sh"</span>]   <span class="comment"># 当容器启动后会自动执行容器内部的/run.sh脚本</span></span><br></pre></td></tr></table></figure></p><p>在Dockerfile的同级目录执行如下命令，该命令会去执行Dockerfile脚本，并构建新的镜像username/my-lamp-app，其中my-lamp-app为自定义的镜像名字，命名成你的即可。如果注册了docker hub，一般将username换层你的用户名，如未注册，可以随便取。我执行的是：“docker build -t icoty1/lamp .”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t username/my-lamp-app .</span><br></pre></td></tr></table></figure></p><h3 id="基于你的镜像运行一个容器"><a href="#基于你的镜像运行一个容器" class="headerlink" title="基于你的镜像运行一个容器"></a>基于你的镜像运行一个容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v /home/icoty/app/:/app/ -p 80:80 -p 3306:3306 username/my-lamp-app</span><br></pre></td></tr></table></figure><ol><li>-v /home/icoty/app/:/app/ 表示将/home/icoty/app/目录映射到容器内部的/app/目录，其中/home/icoty/app/为我的php项目存放位置，需要换成你的。</li><li>-p 80:80 表示将本机的80端口映射到容器内部的80端口，在容器外面是无法直接访问容器内部端口的，映射后才可以，这样当本机80端口收到数据后会自动转发给容器内部的80端口，不过在容器内部是可以直接访问其他远程主机的，这点保证了容器的封闭性和安全性。</li><li>username/my-lamp-app 为前面自定义的镜像名称。</li></ol><h3 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a   <span class="comment"># 查看上一步运行的容器，找到username/my-lamp-app对应的CONTAINER ID</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it ID /bin/bash   <span class="comment"># 根据容器ID进入容器，其中ID为前一句找到的CONTAINER ID</span></span><br><span class="line">$ chown -R www-data:www-data /app/   <span class="comment"># 将php项目目录权限修改为运行apache的用户组，否则会因为权限不够，web页面打不开</span></span><br></pre></td></tr></table></figure><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/public/index.php</span><br></pre></td></tr></table></figure><p>注意：/app/目录下的各个子目录下如果存在.htaccess 文件，会导致web页面无法访问对应子目录，只需将.htaccess重命名为.htaccess.bak即可解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;若你的mac或Linux环境上未安装Docker，请移步&lt;a href=&quot;http://www.runoob.com/docker/ubuntu-docker-install.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker安装&lt;/a&gt;
      
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="LAMP" scheme="http://yoursite.com/tags/LAMP/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
  </entry>
  
</feed>
